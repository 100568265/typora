# 动态代理

## **静态代理**

**特点：**

1. 目标对象实现业务接口
2. 代理对象和目标对象实现同一个业务接口
3. 代理对象在程序运行前就已经以.java文件形式存在
4. 静态代理可以实现目标对象的灵活切换
5. 静态代理的弊端是业务处理不灵活，业务和代理对象紧耦合在一起



静态代理案例：

需求：为庆祝元旦，学校要举办跨年演唱会，请明星。

请刘德华来表演。（目标对象）====>表演

联系刘德华的主力。（代理对象）====>商定时间，地点，费用

学校							（客户端）====>欣赏表演



### 面向接口编程

1. 类中的成员变量设计为接口
2. 方法的形参设计为接口
3. 方法的返回值设计为接口
4. 调用时接口指向实现类

## **动态代理**

### JDK动态代理

就是解耦合，如果业务功能增加了，代理对象不变。

JDK动态代理使用底层的API实现。

Proxy类，`java.lang.reflect.Proxy`，它是用来生成动态代理对象的。

`InvocationHandler`接口，用来进行代理功能+业务功能的整合。

Method类，用来用过反射调用目标方法，这样可以实现目标方法的灵活切换。

**特点：**

1. 目标对象必须实现接口
2. JDK动态代理对象不需要实现接口（解耦合）
3. JDK代理对象实在程序运行时动态在内存中构建的
4. JDK动态代理实现了目标对象和业务功能的灵活切换



```java
public Object getAgent(){
    return Proxy.newProxyInstance(
    //ClassLoader loader:类加载器，加载目标对象到jvm处理
    target.getClass().getClassLoader(),
    //Class<?>[] interfaces:得到目标对象的实现的所有接口
        target.getClass().getInterfaces(),
    //InvocationHandler h:代理处理器，增强功能的代码写这
    new InvocationHandler(){
        @Override
        public Object invoke(
        	//传入生成的代理对象
            Object proxy,
            //通过反射调用的目标方法
            Method method,
            //目标方法的参数
            Object[] args) throws Throwable{
            System.out.println("预定时间...");
            System.out.println("预定场地...");
            //实现目标方法的功能
            //target.sing();
            Object result = method.invoke(target,args);
            System.out.println("结算费用");
            return result;//这个返回值就是目标方法的返回值
        }
        )
    }
    )
}
```



### CGLib动态代理

它是子类代理的方式进行功能增强。通过字节码框架ASM动态生成子类，重写父类的方法进行代理。

特点：

1. 目标对象不用实现业务接口
2. 动态构建子类进行代理功能
3. 通过字节码框架ASM实现代理，需要导包





