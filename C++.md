# C++



## C++基础



### 字符和字符串字面值

由单引号括起来的一个字符成为**char型字面值**，双引号括起来的0个或多个字符则构成**字符串型字面值**。

```cpp
'a'				//字符字面值
"Hello World!"	//字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的数组(array)，编译器在每个字符串的结尾处添加一个空字符(`'\0'`)。

因此，字符串字面值的实际长度要比它的内容多1。

nullptr是指针字面值。





### 初始化和赋值

**在C++中，初始化和赋值是两个完全不同的概念。**



**内置类型默认初始化：**

任何函数体之外的变量初始化为0

函数体之内的变量的值是未定义的

```cpp
std::string global_str;	//空串?
int global_int;	//0
int main()
{
	int local_int;			//不可预测的值
    std::string local_str;	//不可预测的值
}
```





### 变量的声明和定义

**声明**使得名字为程序所知，规定了变量的类型和名字。

**定义**除此之外还申请存储空间，也可能会给变量赋初值。

如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：

```cpp
extern int i;	//声明i而非定义i
int j;			//声明并定义j。
//在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
```



声明和定义的区别非常重要，如果要在**多个文件中使用同一个变量**，就必须将**声明和定义分离**。

此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，**绝不能重复定义**。





### 引用

引用必须初始化。

引用一旦初始化完成，将和它的初始化对象一直绑定，不能重新绑定另一个对象。





### 空指针

空指针不指向任何对象，在试图使用一个指针前可以先检查是否为空。

```cpp
int *p1 = nullptr;	//等价于int *p1 = 0;
int *p2 = 0;
```





### 指针和const

const一旦初始化就不能修改，因此const对象必须初始化。

如果想在多个文件间共享const对象，必须在变量的定义之前添加extern关键字。





### constexpr

**常量表达式**是指值不会改变并且在**编译过程就能得到计算结果**的表达式。

字面值属于常量表达式。

```cpp
int staff_size = 27;		//不是常量表达式
const int sz = get_size();	//不是常量表达式

const int max_files = 20;			//是常量表达式
const int limit = max_files + 1;	//是常量表达式
```



**constexpr变量**

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量值是否是一个常量表达式。

声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```cpp
constexpr int mf = 20;			//20是常量表达式
constexpr int limit = mf + 1;	//mf +1是常量表达式
constexpr int sz = size();		//只有当size是一个constexpr函数时才是一条正确的声明语句
```





### auto和decltype

**auto**

auto可以让编译器通过**初始值**来推算变量的类型。



**decltype**

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是**不想用该表达式的值初始化变量**。

为了满足此需要，C++11引入了第二种**类型说明符**`decltype`，它的作用是选择并返回操作数的数据类型。

此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:

```cpp
decltype(f()) sum = x;	//sum的类型就是函数f()的返回类型
```

