# 1.Python



## 输入&输出



**输入**

input(prompt)

prompt：提示信息，string类型

函数接受一个标准输入数据，返回为string类型

```python
name = input("请输入你的姓名: ")
print(name,"您好，很高兴认识你！")
```





**输出**

- print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
- objects：输出的对象，输出多个对象时，需要用逗号分隔，对象会被转成字符串再输出
- sep：输出的对象用什么间隔开来，默认值是一个空格
- end：输出最后用什么结尾，默认值是换行符'\n'
- file：要写入的文件对象，默认为sys.stdout，指向控制台
- flush：通常输出是否被缓存决定于flush，如果flush参数为True，流会被强制刷新







## 序列的切片

六个标准的数据类型中是序列的有：字符串(String)，列表(List)，元组(Tuple)



**序列索引：**

正向索引，下标从0开始

反向索引，下标从-1开始

![image-20230715021607400](./assets/image-20230715021607400.png)





**切片：**

切片可以访问一个序列的某一个片段。

str[起始索引 : 末尾索引后一位 : 步长]

```python
str[7:9]	# 索引7-8
str[:5]		# 起始索引默认为0
str[::2]	# 结束索引没写，默认为序列长度
```

步长为整数，从左往右

步长为负数，从右往左



**len(str)**：获取字符串str的长度



**注意：**索引会降维度，切片不会降维度

















## 基本数据类型

Python 3中有六个标准的数据类型：

- 数字(Number)
- 字符串(String)
- 列表(List)
- 元组(Tuple)
- 字典(Dictionary)
- 集合(Set)







### 数字(Number)

特点：Number是不可变的，它不是序列

分类：int, float, bool, complex



**整数(int)**

理论上可以无限大，无限小。但实际上受内存限制



**浮点数(float)**

带一个小数点，也可以加一个科学计数法标志e或者E，例如：3.14e-10



**布尔型(bool)**

在python 3中，把True和False定义成了关键字，bool型其实是int类型的子类。

bool类在数字运算时，会被看做成1和0



**复数(complex)**

实部+虚部，和数学中a+bi是一样的。但是这里要用j来表示虚部。例如：2+3j





**数字类型转换**

type(object)

- 返回object的类型



int(x)

float(x)

bool(x)

complex(real,imag)



### 字符串(String)

String是不可变的，它是序列

单行字符串

```python
#单引号字符串
str1 = '今天我很开始，因为我起得很早'
#双引号字符串
str2 = "今天我很开心，因为我起得很早"
#三引号字符串
str3 = """今天我很开心，因为我起得很早"""
```





#### **字符串格式化**

①用%格式化

```python
print("您的姓名是: %s\n您的年龄是: %s\n您的地址是: %s" % (name,age,address))
```

②fstring格式

```python
print(f'{num:>8}') 		# 总宽度为8，右对齐，默认空格填充
print(f'{num:0>8}')  	# 总宽度为8，右对齐，使用0填充
print(f'{num:a<8}')  	# 总宽度为8，左对齐，使用a填充
```





#### 字符串对象方法

`str.replace(老字符串, 新字符串 [,count])`

**功能：**用新字符串替换旧字符串并返回

count：要替换的最大次数，默认为1次

```python
s = "Line1 Line2 Line4"
rs = s.replace("Li","b")
```



`str.strip([chars])`

**功能：**从字符串左右两边删除指定的字符序列，默认删除空字符。

```python
str.strip("rw")
```





`str1.startswith(prefix[,start][,end])`

**功能：**判断字符串是否以prefix开头，是则返回True

```python
str1 = "hello world"
print(str1.startswith("h"))			#True
print(str1.startswith("w",6,8))		#True
```



`str1.endswith(suffix[,start][,end])`

**功能：**判断字符串是否以suffix结尾，是则返回True



`str.isalnum()`	    如果学符串中的所有子符都是子母、文字或数子，则返回 True，否则为 False

`str.isalpha()`		  如果字符串中的所有字符都是字母、文字，则返回True，否则为 False

`str.isdigit()` 	   	如果字符串中的所有字符都是数字，则返回 True，否则为 False

`str.isspace()` 		如果字符串中只有空白符(空格、换行符、制表符等)，则返回True，否则为 False





`str.join(iterable)`

iterable：包括string，list，tuple，dict，set等

**功能：**将可迭代对象中的元素(元素必须是字符串类型)以指定的字符连接，返回新的字符串

```python
a = "\\"
s1 = "hello world"
print(a.join(s1))
```





`str.count(sub,start,end)`

**功能：**计算string在字符串str中出现的次数

```python
print("llll".count(ll))
```







`str.find(subl,startl, end])` 			返回从左开始第一次找到指定子字符串时的索引，找不到就返回 -1

`str.rfnd(subl,startl, end]])` 		  返回从右开始第一次找到指定子字符串时的索引，找不到就返回-1

`str.index(subl,startl,end]l)` 		 类似于fnd()，唯一不同在于，找不到就会报错，其他都一样`str.rindex(subl,start,end]l)` 		类似于rfind()，唯一不同在于，找不到就会报错，其他都一样





`str.split(sep=None,maxsplit=-1)`

**sep：**用于分割字符串的分隔符，默认为所有的空白符(空格，换行，制表符等)，并丢弃结果中的**空字符串**

**maxsplit：**最大分隔次数，默认为-1，即分割所有

```python
a = s.split()
```









### 列表(List)

- List是可变的，它是序列
- 在方括号中添加元素，并使用逗号隔开

```python
list1 = ["h","e","l","l","o"," ","1","牛","3"]
# 把 "牛" 改成 "羊"
list1[-2] = "羊"

# 把"牛" "3" 改成"羊" "4"
list[-2:] = ["羊","4"]

# 把右边的可迭代对象中的元素进行操作
list1[-2:] = "1234"
```



`list([iterable])`

将一个iterable对象转换为列表并返回

```python
print(list("China"))		# ['C', 'h', 'i', 'n', 'a']
```





`list.append(x)`

**功能：**在列表的末尾添加一个元素

```python
list = [1,2,3]
list.append(4)
print(list)			# [1, 2, 3, 4]
```

对比list和string的不同：

```python
str1 = "1235"
new_str = str1.replace("5","4")
print(new_str)		# "1234"
```

列表本身是可变的，而字符串本身是不可变的





`list.extend(iterable)`

**功能：**使用iterable中的元素来扩展列表，相当于a[len(a):] = iterable

```python
list = [1,2,3]
list.extend([4,5])
```





`list.insert(element, index)`

**功能：**在给定的位置插入一个元素

```python
list = [1,2,3,4,True,False]
list.insert(4,5)				# [1, 2, 3, 4, 5, True, False]
```





`list.sort([key],reverse=False)`

key：指定一个函数，在排序前，列表每个元素先应用这个函数之后再对原数据进行排序

reverse：默认为False，代表升序，指定为True则降序

对原列表进行排序，无返回值

```python
num_list = [1,-2,5,-3]
num_list.sort()
```



**例：把lis中的元素按照绝对值的大小进行降序**

```python
lis = [-5, 2, 3, 1, 4]
lis.sort(key=abs, reverse=True)
```





### 元组(Tuple)

Tuple和List类似，它也是序列，但Tuple是**不可变**的

**圆括号**中添加元素



**封包：**当把多个元素赋给同一个变量时，会把它们打包成一个元组，这个过程叫封包

```python
tup1 = (1,2,3,"abv")
tup2 = (1,[2,3],(1,2))
```



**tuple([iterable])**

返回一个新的tuple对象，其元素来自于iterable



**元组对象方法**

**注意：**列表中对元素进行修改的方法，元组中都不存在，因为元组是不可变的。



**tuple.index(x)**

**tuple.count(x)**







### **字典(Dictionary)**

字典的每个键值对用冒号:隔开写key:value的格式，写在{}中。

- Dict是可变的，它不是序列。

- 字典的键**必须为不可变**的数据类型：数字，元组，字符串。

- 当键一样的时候，后面的值会覆盖前面的键的值。




```python
dic = {"name": "张三", "age": 18, "gender": "male"}
```



#### 创建字典的6种方式



**①直接在空字典{}里面写键值对**

```python
a = {"name": "张三", "age": 18, "gender": "male"}
print(a)
```

**②定义一个空字典，再往里面添加键值对**

```python
a = dict()
a["姓名"] = "张三"
a["age"] = 18
```

**③把键作为关键字传入**

```python
a = dict(name="张三",age=28)
```

**④可迭代对象方式来构造字典**

```python
# 这里用元组/列表/字典都可以
a = dict([("姓名","张三"),("年龄",28)])
```

**⑤通过zip()把对应元素打包成元组，类似于上一种方法**

```python
a = dict(zip(["姓名","年龄"],["张三",28]))
```





#### 字典对象方法



`dict.keys()`

`dict.values()`

- 返回由字典组成的一个新视图
- 返回的对象是视图对象，这意味着当字典改变时，视图也会相应改变

```python
d1 = {'身高':188,'体重':80,'肤色':'黄色','名字':'张三'}
view = d1.keys()
```



`dict.get(key[,default])`

key：指定的键

default：如果指定的键不存在时

```python
dic = {"身高":180,"体重":80}
value = dic["体","keyError"] # 返回一个字符串keyError
```





`dict.update([other])`

使用来自other的键/值对更新字典，如果键相同，则覆盖原有的键

other：可以是另一个字典对象

```python
dic = {"身高":180,"名字":"张三"}
dic.update([("名字","李四")])
print(dic)
```



`dict.pop(key[, default])`

移除指定的键key，并返回对应的值，如果key不在字典中，则返回default

```python
d1 = {'身高':188,'体重':80,'肤色':'黄色','名字':'张三'}
value = d1.pop("肤色")
print(value)	# 黄色
```



`dict.popitem()`

从字典中移除最后一个键值对，并返回它们构成的元组(键，值)

```python
dic = {'name':'小明','年龄':18,'学历':'本科'}
item = dic.popitem()
```



`dict.copy()`

返回字典的浅拷贝

```python
new_dic = dic.copy()
```



`dict.clear()`

移除字典中所有元素，无返回值







### 集合(Set)

- Set可以改变，它不是序列
- 无序性(集合元素是没有顺序的)
- 不重复性(元素是不重复的)
- 集合里只能包含不可变的数据类型
- 可以使用花括号{}或set()函数创建集合
- 创建空集合必须用set()，因为{}是用来创建空字典的



```python
a = set("abcdefga")
b = set("abc")
c = set("aef")

print(c<=a)	#判断c是否为a的子集
print(c>=a) #判断c是否为a的父集

#差集
print(a-c)

#交集
print(a&b)

#并集
print(a|b)
```



`set([iterable])`

`frozenset([iterable])`

```python
# 集合和冻结集合，冻结集合是不可变的
a = set("abcdefga")
b = fronzenset("abcdefga")
```



`set.add(elem)`

将元素elem添加到集合中

```python
a = {1,2,3}
a.add("hello world")
print(a)
```



`set.remove(elem)`

将元素elem从集合中删除

```python
set1.remove(12)
```



`set.pop()`

从集合中任意删除一个元素

```python
s1.pop()
```







## 浅拷贝&深拷贝

Python中的**赋值语句**不复制对象，只**建立引用关联**，对于可变数据，有时不希望对它进行修改，所以可以把它copy一份，对它的副本进行修改。



````python
import copy as cp
cp.copy()		# 浅拷贝
cp.deepcopy()	# 深拷贝
````



**浅拷贝**

如果浅拷贝对象是**不可变数据类型**，那么和赋值语句等效(没有拷贝的意义)。

如果浅拷贝对象是**可变数据类型**，那么浅拷贝会把该对象复制一份，但是该对象中的**其他所有元素**仍为**引用关系**。



```python
import copy

lis1 = [991, "abc", (9, 993), [994, 995], [888, 887],
{"name": "Tom"}, (996, [997, 998]), (888, (886, 886))]
lis2 = copy.copy(lis1) # 浅拷贝
print(id(lis1))
print(id(lis2))

lis1.append(9)
print(lis1)
print(lis2)
```





**深拷贝**

1. 如果深拷贝对象是**不可变数据类型**(复合类型还需确保其中的所有元素不可变)，那么**拷贝无效**。
2. 如果深拷贝对象带有可变数据类型，深拷贝会把该对象复制一份。
3. 对于其中的元素分别递归的适用于前两点。

```python
# 拷贝无效
import copy
tup1 = (991, "abc")			# 元组本身不可变，内部元素也不可变
tup2 = copy.deepcopy(tup1)
print(id(tup1))
print(id(tup2))
```



```python
# 会发生深拷贝
import copy
# 元组本身不可变，内部元素可变, 最后一个列表发生了拷贝
tup1 = (991, "abc",[11,22,33])
tup2 = copy.deepcopy(tup1)
print(id(tup1))
print(id(tup2))
```







## 运算符

`a += b`

```python
a = [1, 2]
b = a
a += [3, 4]	#inplace操作
print(a)	# [1,2,3,4]
print(b)	# [1,2,3,4]
```



`a = a + b`

```python
a = [1, 2]
b = a
a = a + [3, 4]	#新建操作
print(a)	# [1,2,3,4]
print(b)	# [1,2]
```

增强赋值能够以效率更高的方式处理(不新建)，尽量对元数据进行操作。





### 逻辑运算符

优先级：not > and > or

| 运算符 | 描述                                   |
| ------ | -------------------------------------- |
| and    | 左边为假，返回左边。两边为真，返回右边 |
| or     | 两真，返回左边。两假，返回右边         |
| not    | 返回bool值                             |





### 成员运算符

| 运算符 | 描述     |
| ------ | -------- |
| in     | 在其中   |
| not in | 不在其中 |





### 身份运算符

| 运算符 | 描述                             |
| ------ | -------------------------------- |
| is     | 判断两个标识符是否引用自一个对象 |
| is not | 判断两个标识符是否引用自一个对象 |

ps：判断地址是否相同







### 位运算符

位运算符是把数字转换成二进制来进行计算的

| 运算符 | 描述           |
| ------ | -------------- |
| &      | 按位与运算符   |
| \|     | 按位或运算符   |
| ^      | 按位异或运算符 |
| ~      | 按位取反运算符 |
| <<     | 左移运算符     |
| >>     | 右移运算符     |



进制转换函数



bin(x)：把x转成二进制

oct(x)：把x转成八进制

hex(x)：把x转成十六进制





## random模块

| 函数                                    | 描述                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| random.random()                         | 返回[0.0,1.0) 范围内的随机浮点数                             |
| random.randint(a, b)                    | 返回 [a,b] 范围内的随机整数                                  |
| random.uniform(a, b)                    | 返回 [a,b]范围内的随机浮点数                                 |
| random.choice(seq)                      | 从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发IndexError |
| random.sample(population,k)             | 从序列或者集合中随机获取k个元素，以列表形式返回(Python3.9版本,集合中采样已弃用) |
| random.shuffle(x)                       | 将可变序列x 随机打乱位置                                     |
| random.randrange (start,] stop [,step]) | 等效于从 range(start,stop,step) 里随机返回一个元素           |
| random.seed([x])                        | 起固定随机数的作用，x可以是任意数字 (x 可以理解为种子的名字) |























































