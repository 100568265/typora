# 1.Python



## 输入&输出



**输入**

input(prompt)

prompt：提示信息，string类型

函数接受一个标准输入数据，返回为string类型

```python
name = input("请输入你的姓名: ")
print(name,"您好，很高兴认识你！")
```





**输出**

- print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
- objects：输出的对象，输出多个对象时，需要用逗号分隔，对象会被转成字符串再输出
- sep：输出的对象用什么间隔开来，默认值是一个空格
- end：输出最后用什么结尾，默认值是换行符'\n'
- file：要写入的文件对象，默认为sys.stdout，指向控制台
- flush：通常输出是否被缓存决定于flush，如果flush参数为True，流会被强制刷新







## 序列的切片

六个标准的数据类型中是序列的有：字符串(String)，列表(List)，元组(Tuple)



**序列索引：**

正向索引，下标从0开始

反向索引，下标从-1开始

![image-20230715021607400](./assets/image-20230715021607400.png)





**切片：**

切片可以访问一个序列的某一个片段。

str[起始索引 : 末尾索引后一位 : 步长]

```python
str[7:9]	# 索引7-8
str[:5]		# 起始索引默认为0
str[::2]	# 结束索引没写，默认为序列长度
```

步长为整数，从左往右

步长为负数，从右往左



**len(str)**：获取字符串str的长度



**注意：**索引会降维度，切片不会降维度

















## 基本数据类型

Python 3中有六个标准的数据类型：

- 数字(Number)
- 字符串(String)
- 列表(List)
- 元组(Tuple)
- 字典(Dictionary)
- 集合(Set)







### 数字(Number)

特点：Number是不可变的，它不是序列

分类：int, float, bool, complex



**整数(int)**

理论上可以无限大，无限小。但实际上受内存限制



**浮点数(float)**

带一个小数点，也可以加一个科学计数法标志e或者E，例如：3.14e-10



**布尔型(bool)**

在python 3中，把True和False定义成了关键字，bool型其实是int类型的子类。

bool类在数字运算时，会被看做成1和0



**复数(complex)**

实部+虚部，和数学中a+bi是一样的。但是这里要用j来表示虚部。例如：2+3j





**数字类型转换**

type(object)

- 返回object的类型



int(x)

float(x)

bool(x)

complex(real,imag)



### 字符串(String)

String是不可变的，它是序列

单行字符串

```python
#单引号字符串
str1 = '今天我很开始，因为我起得很早'
#双引号字符串
str2 = "今天我很开心，因为我起得很早"
#三引号字符串
str3 = """今天我很开心，因为我起得很早"""
```





#### **字符串格式化**

①用%格式化

```python
print("您的姓名是: %s\n您的年龄是: %s\n您的地址是: %s" % (name,age,address))
```

②fstring格式

```python
print(f'{num:>8}') 		# 总宽度为8，右对齐，默认空格填充
print(f'{num:0>8}')  	# 总宽度为8，右对齐，使用0填充
print(f'{num:a<8}')  	# 总宽度为8，左对齐，使用a填充
```





#### 字符串对象方法

`str.replace(老字符串, 新字符串 [,count])`

**功能：**用新字符串替换旧字符串并返回

count：要替换的最大次数，默认为1次

```python
s = "Line1 Line2 Line4"
rs = s.replace("Li","b")
```



`str.strip([chars])`

**功能：**从字符串左右两边删除指定的字符序列，默认删除空字符。

```python
str.strip("rw")
```





`str1.startswith(prefix[,start][,end])`

**功能：**判断字符串是否以prefix开头，是则返回True

```python
str1 = "hello world"
print(str1.startswith("h"))			#True
print(str1.startswith("w",6,8))		#True
```



`str1.endswith(suffix[,start][,end])`

**功能：**判断字符串是否以suffix结尾，是则返回True



`str.isalnum()`	    如果学符串中的所有子符都是子母、文字或数子，则返回 True，否则为 False

`str.isalpha()`		  如果字符串中的所有字符都是字母、文字，则返回True，否则为 False

`str.isdigit()` 	   	如果字符串中的所有字符都是数字，则返回 True，否则为 False

`str.isspace()` 		如果字符串中只有空白符(空格、换行符、制表符等)，则返回True，否则为 False





`str.join(iterable)`

iterable：包括string，list，tuple，dict，set等

**功能：**将可迭代对象中的元素(元素必须是字符串类型)以指定的字符连接，返回新的字符串

```python
a = "\\"
s1 = "hello world"
print(a.join(s1))
```





`str.count(sub,start,end)`

**功能：**计算string在字符串str中出现的次数

```python
print("llll".count(ll))
```







`str.find(subl,startl, end])` 			返回从左开始第一次找到指定子字符串时的索引，找不到就返回 -1

`str.rfnd(subl,startl, end]])` 		  返回从右开始第一次找到指定子字符串时的索引，找不到就返回-1

`str.index(subl,startl,end]l)` 		 类似于fnd()，唯一不同在于，找不到就会报错，其他都一样`str.rindex(subl,start,end]l)` 		类似于rfind()，唯一不同在于，找不到就会报错，其他都一样





`str.split(sep=None,maxsplit=-1)`

**sep：**用于分割字符串的分隔符，默认为所有的空白符(空格，换行，制表符等)，并丢弃结果中的**空字符串**

**maxsplit：**最大分隔次数，默认为-1，即分割所有

```python
a = s.split()
```









### 列表(List)

- List是可变的，它是序列
- 在方括号中添加元素，并使用逗号隔开

```python
list1 = ["h","e","l","l","o"," ","1","牛","3"]
# 把 "牛" 改成 "羊"
list1[-2] = "羊"

# 把"牛" "3" 改成"羊" "4"
list[-2:] = ["羊","4"]

# 把右边的可迭代对象中的元素进行操作
list1[-2:] = "1234"
```



`list([iterable])`

将一个iterable对象转换为列表并返回

```python
print(list("China"))		# ['C', 'h', 'i', 'n', 'a']
```





`list.append(x)`

**功能：**在列表的末尾添加一个元素

```python
list = [1,2,3]
list.append(4)
print(list)			# [1, 2, 3, 4]
```

对比list和string的不同：

```python
str1 = "1235"
new_str = str1.replace("5","4")
print(new_str)		# "1234"
```

列表本身是可变的，而字符串本身是不可变的





`list.extend(iterable)`

**功能：**使用iterable中的元素来扩展列表，相当于a[len(a):] = iterable

```python
list = [1,2,3]
list.extend([4,5])
```





`list.insert(element, index)`

**功能：**在给定的位置插入一个元素

```python
list = [1,2,3,4,True,False]
list.insert(4,5)				# [1, 2, 3, 4, 5, True, False]
```





`list.sort([key],reverse=False)`

key：指定一个函数，在排序前，列表每个元素先应用这个函数之后再对原数据进行排序

reverse：默认为False，代表升序，指定为True则降序

对原列表进行排序，无返回值

```python
num_list = [1,-2,5,-3]
num_list.sort()
```



**例：把lis中的元素按照绝对值的大小进行降序**

```python
lis = [-5, 2, 3, 1, 4]
lis.sort(key=abs, reverse=True)
```





### 元组(Tuple)

Tuple和List类似，它也是序列，但Tuple是**不可变**的

**圆括号**中添加元素



**封包：**当把多个元素赋给同一个变量时，会把它们打包成一个元组，这个过程叫封包

```python
tup1 = (1,2,3,"abv")
tup2 = (1,[2,3],(1,2))
```



**tuple([iterable])**

返回一个新的tuple对象，其元素来自于iterable



**元组对象方法**

**注意：**列表中对元素进行修改的方法，元组中都不存在，因为元组是不可变的。



**tuple.index(x)**

**tuple.count(x)**







### **字典(Dictionary)**

字典的每个键值对用冒号:隔开写key:value的格式，写在{}中。

- Dict是可变的，它不是序列。

- 字典的键**必须为不可变**的数据类型：数字，元组，字符串。

- 当键一样的时候，后面的值会覆盖前面的键的值。




```python
dic = {"name": "张三", "age": 18, "gender": "male"}
```



#### 创建字典的6种方式



**①直接在空字典{}里面写键值对**

```python
a = {"name": "张三", "age": 18, "gender": "male"}
print(a)
```

**②定义一个空字典，再往里面添加键值对**

```python
a = dict()
a["姓名"] = "张三"
a["age"] = 18
```

**③把键作为关键字传入**

```python
a = dict(name="张三",age=28)
```

**④可迭代对象方式来构造字典**

```python
# 这里用元组/列表/字典都可以
a = dict([("姓名","张三"),("年龄",28)])
```

**⑤通过zip()把对应元素打包成元组，类似于上一种方法**

```python
a = dict(zip(["姓名","年龄"],["张三",28]))
```





#### 字典对象方法



`dict.keys()`

`dict.values()`

- 返回由字典组成的一个新视图
- 返回的对象是视图对象，这意味着当字典改变时，视图也会相应改变

```python
d1 = {'身高':188,'体重':80,'肤色':'黄色','名字':'张三'}
view = d1.keys()
```



`dict.get(key[,default])`

key：指定的键

default：如果指定的键不存在时

```python
dic = {"身高":180,"体重":80}
value = dic["体","keyError"] # 返回一个字符串keyError
```





`dict.update([other])`

使用来自other的键/值对更新字典，如果键相同，则覆盖原有的键

other：可以是另一个字典对象

```python
dic = {"身高":180,"名字":"张三"}
dic.update([("名字","李四")])
print(dic)
```



`dict.pop(key[, default])`

移除指定的键key，并返回对应的值，如果key不在字典中，则返回default

```python
d1 = {'身高':188,'体重':80,'肤色':'黄色','名字':'张三'}
value = d1.pop("肤色")
print(value)	# 黄色
```



`dict.popitem()`

从字典中移除最后一个键值对，并返回它们构成的元组(键，值)

```python
dic = {'name':'小明','年龄':18,'学历':'本科'}
item = dic.popitem()
```



`dict.copy()`

返回字典的浅拷贝

```python
new_dic = dic.copy()
```



`dict.clear()`

移除字典中所有元素，无返回值







### 集合(Set)

- Set可以改变，它不是序列
- 无序性(集合元素是没有顺序的)
- 不重复性(元素是不重复的)
- 集合里只能包含不可变的数据类型
- 可以使用花括号{}或set()函数创建集合
- 创建空集合必须用set()，因为{}是用来创建空字典的



```python
a = set("abcdefga")
b = set("abc")
c = set("aef")

print(c<=a)	#判断c是否为a的子集
print(c>=a) #判断c是否为a的父集

#差集
print(a-c)

#交集
print(a&b)

#并集
print(a|b)
```



`set([iterable])`

`frozenset([iterable])`

```python
# 集合和冻结集合，冻结集合是不可变的
a = set("abcdefga")
b = fronzenset("abcdefga")
```



`set.add(elem)`

将元素elem添加到集合中

```python
a = {1,2,3}
a.add("hello world")
print(a)
```



`set.remove(elem)`

将元素elem从集合中删除

```python
set1.remove(12)
```



`set.pop()`

从集合中任意删除一个元素

```python
s1.pop()
```







## 浅拷贝&深拷贝

Python中的**赋值语句**不复制对象，只**建立引用关联**，对于可变数据，有时不希望对它进行修改，所以可以把它copy一份，对它的副本进行修改。



````python
import copy as cp
cp.copy()		# 浅拷贝
cp.deepcopy()	# 深拷贝
````



**浅拷贝**

如果浅拷贝对象是**不可变数据类型**，那么和赋值语句等效(没有拷贝的意义)。

如果浅拷贝对象是**可变数据类型**，那么浅拷贝会把该对象复制一份，但是该对象中的**其他所有元素**仍为**引用关系**。



```python
import copy

lis1 = [991, "abc", (9, 993), [994, 995], [888, 887],
{"name": "Tom"}, (996, [997, 998]), (888, (886, 886))]
lis2 = copy.copy(lis1) # 浅拷贝
print(id(lis1))
print(id(lis2))

lis1.append(9)
print(lis1)
print(lis2)
```





**深拷贝**

1. 如果深拷贝对象是**不可变数据类型**(复合类型还需确保其中的所有元素不可变)，那么**拷贝无效**。
2. 如果深拷贝对象带有可变数据类型，深拷贝会把该对象复制一份。
3. 对于其中的元素分别递归的适用于前两点。

```python
# 拷贝无效
import copy
tup1 = (991, "abc")			# 元组本身不可变，内部元素也不可变
tup2 = copy.deepcopy(tup1)
print(id(tup1))
print(id(tup2))
```



```python
# 会发生深拷贝
import copy
# 元组本身不可变，内部元素可变, 最后一个列表发生了拷贝
tup1 = (991, "abc",[11,22,33])
tup2 = copy.deepcopy(tup1)
print(id(tup1))
print(id(tup2))
```







## 运算符

`a += b`

```python
a = [1, 2]
b = a
a += [3, 4]	#inplace操作
print(a)	# [1,2,3,4]
print(b)	# [1,2,3,4]
```



`a = a + b`

```python
a = [1, 2]
b = a
a = a + [3, 4]	#新建操作
print(a)	# [1,2,3,4]
print(b)	# [1,2]
```

增强赋值能够以效率更高的方式处理(不新建)，尽量对元数据进行操作。





### 逻辑运算符

优先级：not > and > or

| 运算符 | 描述                                   |
| ------ | -------------------------------------- |
| and    | 左边为假，返回左边。两边为真，返回右边 |
| or     | 两真，返回左边。两假，返回右边         |
| not    | 返回bool值                             |





### 成员运算符

| 运算符 | 描述     |
| ------ | -------- |
| in     | 在其中   |
| not in | 不在其中 |





### 身份运算符

| 运算符 | 描述                             |
| ------ | -------------------------------- |
| is     | 判断两个标识符是否引用自一个对象 |
| is not | 判断两个标识符是否引用自一个对象 |

ps：判断地址是否相同







### 位运算符

位运算符是把数字转换成二进制来进行计算的

| 运算符 | 描述           |
| ------ | -------------- |
| &      | 按位与运算符   |
| \|     | 按位或运算符   |
| ^      | 按位异或运算符 |
| ~      | 按位取反运算符 |
| <<     | 左移运算符     |
| >>     | 右移运算符     |



进制转换函数



bin(x)：把x转成二进制

oct(x)：把x转成八进制

hex(x)：把x转成十六进制





## random模块

| 函数                                    | 描述                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| random.random()                         | 返回[0.0,1.0) 范围内的随机浮点数                             |
| random.randint(a, b)                    | 返回 [a,b] 范围内的随机整数                                  |
| random.uniform(a, b)                    | 返回 [a,b]范围内的随机浮点数                                 |
| random.choice(seq)                      | 从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发IndexError |
| random.sample(population,k)             | 从序列或者集合中随机获取k个元素，以列表形式返回(Python3.9版本,集合中采样已弃用) |
| random.shuffle(x)                       | 将可变序列x 随机打乱位置                                     |
| random.randrange (start,] stop [,step]) | 等效于从 range(start,stop,step) 里随机返回一个元素           |
| random.seed([x])                        | 起固定随机数的作用，x可以是任意数字 (x 可以理解为种子的名字) |





## 循环语句



### **while...else语句**

while执行完后，再执行else

```python
while count < 5:
    print(count,"小于5")
    count+=1
else:
    print(count,"大于或等于5")
```





### **for循环**

`for 变量 in 可迭代对象:`

​    `执行语句...`

```python
lis = [(1, 2), (3, 4), (5, 6)]
for var1, var2 in lis:
    print(var1, var2)
    
# output:    
"""
1 2
3 4
5 6
"""
```

如果变量用不到，可以用**`_`**代替

```python
for _ in range(3):
    print("hello")
```





### **for嵌套循环**

```python
# 打印九九乘法表
for i in range(1,10):
    for j in range(1,i+1):
        print(f"{i} * {j} = {i*j}",end="\t")
    print()
```





### enumerate

用枚举不仅可以遍历元素，还可以拿到索引

```python
lis = ['a', 'bc', 'd']
for index,item in enumerate(lis,start=1):
    print(index,item)
```





### 列表推导式

由一对方括号里面包含一个表达式，后面跟一个for子句，其结果是一个新列表，由表达式根据后面的for和if子句的内容进行求值计算而得出

```python
squares = []
for x in range(10):
    squares.append(x**2)
    
squares = [x**2 for x in range(10)]

lis = [(x,y) for x in range(3) for y in range(4,7)]

# 等价于
lis = []
for x in range(3):
    for y in range(4,7):
        lis.append((x,y))
print(lis)
```





### 内存自动管理问题

**字典/集合**在迭代时改变size，会导致报错：

```python
dic = {"name": "Tom", "age": 18, "height": 188}
for key in dic:
    print(key)
    dic.pop(key)
    print(dic)
# RuntimeError: dictionary changed size during iteration
```









## 函数



**自定义函数**

**格式：**

```python
def func_name():
    func_body
```





**return用法**

return后面可以跟单个对象，多个对象，表达式

```python			
def add(num1,num2):
    return num1 + num2
```





### **参数传递**

---



1. Python参数传递统统都是引用传递
2. 如果传递的实参是**可变数据类型**，函数会同步影响原数据
3. 如果传递的实参时**不可变类型**，函数不会对原数据进行修改





### 参数分类

---



**必须参数**

必须传参，否则报错(实参按照形参的对应位置传递)





**关键字参数**

通过关键字传入值(无所谓顺序)



**默认参数**

默认参数不能写在必须参数的前面，不能写在**kwargs的后面

```python
def info(name,age=18):
    print("姓名:",name)
    print("年龄:",age)
    
info("小明")
```



**不定长参数**

`*args`：将实参打包成元组给函数体调用

```python
def func(b,c,*a):
    print(b,c,a)

func(1,2,3,4,5) # 1->b 2->c 3,4,5->*a
```



`**kwargs`：将实参打包成字典给函数体调用，如果没有值传给它，就是个空字典

```python
def func(a,b,**kwargs):
    print(a,b,**kwargs)
    
func(1,2)
func(1,2,name='Tom', age=18, height=188)
```



**特殊参数**

- 可以用 `/` 和 `*` 来限制参数传递形式
- `/`为仅限位置参数，`*`为仅限关键字参数
- 在他们之后的参数必须以规定的格式传入







### 匿名函数

---



- 格式：`lamda[arg1,[arg2...argN]]:expression`
- 匿名函数的参数可以有多个，但是后面的expression只能有一个
- 匿名函数的返回值就是expression的结果，不需要return
- 匿名函数可以作为一个表达式，而不是一个结构化的代码块

```python
# 定义匿名函数
func = lambda left,right:left+right
func(2,3)
```

可以把匿名函数作为实参传给其他函数调用







### 封包&解包

---





**封包**

将多个值赋给一个变量时，Python会自动将这些值封装成**元组**，这个特性称之为封包：

```python
a = 1, 2, 3, 4
print(a)
```



**解包**

可迭代对象都支持解包

```python
# 解包
a, b, c, d = [1, 2, 3, 4]
print(a)
print(b)
print(c)
print(d)
```

```python
a,*b,c,d = "hello"

*a, = "hello"
print(a) 	#['h','e','l','l','o']
```

```python
def func(arg1,arg2,arg3,arg4,arg5):
    print(arg1,arg2,arg3,arg4,arg5)

a = "hello"
func(*a)	# 解包
```

```python
dic = {'name': 'Tom', 'age': 18, "height": 188}


def func(name, age, height, d=None):
    print(name, age, height, d)


func(**dic)
```







### 命名空间&作用域

---



#### **命名空间**

**定义：**命名空间是一个从名称到对象的映射

**实现：**大部分命名空间当前由Python字典实现

**作用：**提供了在项目中避免名字冲突的一种方法

**描述：**各个命名空间是独立的，没有任何关系。

一个命名空间中不能有重名，但不同的命名空间是可以重名的





**内置命名空间**

包含所有Python内置对象的名称

在解释器启动时创建，持续到解释器终止

```python
import builtins

print(dir(builtins))
```



 **全局命名空间**

- 包含模块中定义的名称，模块的变量名，函数，类，其他导入模块等
- 在模块被读入时创建，持续到解释器退出





**局部命名空间**

- 包含**函数**中定义的名称，记录了函数的变量，参数等
- 一个函数的局部命名空间在这个函数被调用时创建，函数退出时结束









#### 作用域

定义：Python程序可以直接访问命名空间的正文区域

作用：决定了哪一部分区域可以访问哪些特定的名称



**global和nonlocal**

当内部作用域想给外部作用域的变量重新赋值时，可以用`global`或`nonlocal`关键字

```python
def outer():
    a = 2
    def inner():
        global a
        a = 3
    return inner()

a = 1
outer()
print(a)  # a=3
```



```python
def outer():
    a = 2
    def inner():
        nonlocal a
        a = 3
    return inner()

a = 1
outer()
print(a)  # 2
```







#### 递归函数

**定义：**程序调用自身的编程技巧称为递归。

一般来说，递归需要满足2个条件：

- 递归边界条件(终止条件)
- 递归推理(提取重复的子问题，不断向边界条件靠拢)



```python
# 斐波那契数列
# m -> months
def get_rabbits(m):
    if m < 2:
        return 1
    return get_rabbits(m - 1) + get_rabbits(m - 2)
```







## 面向对象

**魔术方法：**以双下划线开头，双下划线结尾的方法

魔术方法不需要手动调用，它会在特定的情况下被自动调用

**自动调用条件：**当**实例化**的时候，会自动调用

```python
class Student:
    # 魔术方法
    def __init__(self,name,age,address):
        self.name = name
        self.age = age
        self.address = address

obj = Student("张三",18,"张家巷")		# 实例化
```

实例化 ->自动调用 `__new__` -> 自动调用`__init__`

实例对象是由`__new__`创建和返回的，由`__init__`定制的





### 类，对象，静态方法

**对象方法**隐式地接收了**self**参数，**类方法**隐式地接收了**cls**参数

```python
def eat(self):	# 对象方法
    print(f"{self.name}吃饭")

@classmethod 	# 类方法的装饰器
def sleep(cls):
    print(f"{cls.school}的学生睡觉")

@staticmethod	# 静态方法的装饰器 
def wash():
    pass


stu1 = Student()
# 对象方法调用
stu1.eat()
# 类方法调用
Student.sleep()
# 静态方法调用
Student.wash()
```



**删除属性**

```python
# 删除类的属性
delattr(Person,"eat")
"""等价于 del Person.eat """
```





### 封装

- 在属性或方法前面加`__`开头，声明为私有属性或私有方法
- 私有属性或私有方法只能类内调用
- 但是可以提供公有方法来访问私有属性，或调用私有方法
- 子类无法继承父类的私有属性和私有方法





### 继承

- 所有的类默认继承object
- 子类会拥有父类中所有的非私有属性和方法

```python
# 单继承
class Person:
    ...
    
class Student(Person):
    ...
    
class Worker(Person):
    ...
```

```python
# 多继承
class Ragdoll(Animal,Cat):	# 继承多个父类
```





子类优先使用自己的方法，如果没有再调用父类的方法

使用**super**直接调用父类的方法：

```python
class Cat(Animal):
    def eat(self):
        print(f'猫吃{self.food}')
        super().eat()	# 默认调用当前类的父类
        
# 也可以在外面调用
c = Cat('🐟')
super(Cat,c).eat()		# 调用父类的eat()方法
```







### 多态

具有不同内容的方法可以使用相同的方法名，则可以用一个方法名调用不同内容的方法



















